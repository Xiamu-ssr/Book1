# 2.1 GCN

```python
# 导入相关库
import typing
import torch
import torch.nn as nn
import torch.nn.functional as F
import torch_geometric.nn
from torch_geometric.data import Data, DataLoader
from torch_geometric.datasets import Planetoid
from torch_geometric.nn import GCNConv
from model.GCN import GCN
```

```python
# 下载数据集
device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
print(f"device : {device}")

from torch_geometric.datasets import Planetoid
dataset = Planetoid(root='./data/Cora', name='Cora')
graph = dataset[0].to(device)
```

```python
# 查看图信息
print(graph)
print(f"train num : {graph.train_mask.sum()}")
print(f"val num : {graph.val_mask.sum()}")
print(f"test num : {graph.test_mask.sum()}")
print(f"num classes : {dataset.num_classes}")
```

```
Data(x=[2708, 1433], edge_index=[2, 10556], y=[2708], train_mask=[2708], val_mask=[2708], test_mask=[2708])
train num : 140
val num : 500
test num : 1000
num classes : 7

x：节点特征矩阵，大小为[num_nodes, num_node_features]，其中num_nodes是图中节点的数量，num_node_features是每个节点的特征维度。例如，对于Cora数据集，x的大小为[2708, 1433]，表示数据集中包含2708个节点，每个节点有1433个特征。
edge_index：边索引矩阵，大小为[2, num_edges]，其中num_edges是图中边的数量。edge_index矩阵用于表示图中的边，其中每列表示一条边的两个端点。例如，对于Cora数据集，edge_index的大小为[2, 10556]，表示数据集中存在10556条边。
y：节点标签向量，大小为[num_nodes]，其中每个元素表示对应节点的类别标签。例如，对于Cora数据集，y的大小为[2708]，表示数据集中每个节点都有一个类别标签，取值范围为0到6。
train_mask：训练集节点的掩码向量，大小为[num_nodes]，其中每个元素为True或False，表示对应节点是否属于训练集。例如，对于Cora数据集，train_mask的大小为[2708]，表示数据集中的所有节点都有一个掩码值，其中True表示该节点属于训练集。
val_mask：验证集节点的掩码向量，大小和train_mask相同，其中每个元素为True或False，表示对应节点是否属于验证集。
test_mask：测试集节点的掩码向量，大小和train_mask相同，其中每个元素为True或False，表示对应节点是否属于测试集。
```

<pre class="language-python"><code class="lang-python"><strong>#设置参数
</strong><strong>epochs = 256 # 训练轮数
</strong>lr = 0.01 # 学习率
val_record_interval = 8
in_channels = graph.x.shape[1]
hidden_channels = 16 # 隐藏层维度
out_channels = dataset.num_classes
</code></pre>

<pre class="language-python"><code class="lang-python"><strong>#建立模型
</strong><strong>model = GCN(in_channels=in_channels, hidden_channels=hidden_channels,num_layers=2, out_channels=out_channels).to(device)
</strong>optimizer = torch.optim.Adam(model.parameters(), lr = lr, weight_decay=5e-4)
loss_func = nn.NLLLoss()
m = nn.LogSoftmax(dim=1)
</code></pre>

```python
#训练，验证，记录
loss_x = [e for e in range(epochs)]
loss_record = []
acc_x = [e for e in range(epochs) if e%val_record_interval == 0]
acc_record = []
for epoch in range(epochs):
    model.train()
    optimizer.zero_grad()
    out = model(graph.x, graph.edge_index)
    # print(out.shape)
    loss = loss_func(m(out[graph.train_mask]), graph.y[graph.train_mask])
    loss_record.append(loss.item())
    loss.backward()
    optimizer.step()
    if epoch % val_record_interval == 0:
        model.eval()
        _, pred = model(graph.x, graph.edge_index).max(dim=1)
        correct = float(pred[graph.val_mask].eq(graph.y[graph.val_mask]).sum().item())
        acc = correct / graph.val_mask.sum().item()
        acc_record.append(acc)
```

```python
#作图
import matplotlib.pyplot as plt

plt.subplot(1, 2, 1)
plt.plot(loss_x, loss_record)
plt.title('Loss')
plt.xlabel('epoch')
plt.ylabel('loss')

plt.subplot(1, 2, 2)
plt.plot(acc_x, acc_record)
plt.title('Acc')
plt.xlabel('epoch')
plt.ylabel('acc')

plt.show()
```

```python
#模型测试
model.eval()
_, pred = model(graph.x, graph.edge_index).max(dim=1)
correct = float(pred[graph.test_mask].eq(graph.y[graph.test_mask]).sum().item())
acc = correct / graph.test_mask.sum().item()
# print(graph.test_mask.sum().item())
print(f"acc : {acc}")
```
